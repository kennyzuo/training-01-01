## ECMAScript 新特性

### 概述

ECMAScript 定义了语言层面的规范，包括变量定义、函数声明、逻辑语句等

JavaScript 是 ECMAScript 扩展，在浏览器环境下

- Core - ECMAScript 语言层面实现
- DOM
- BOM

ECMAScript 从 ES5 到 ES6（ES2015） 经历了6年时间，因而新增了很多东西，此后，ECMAScript 保持每年一次的版本迭代，命名按照年份定义，如 ES2015、ES2016 等

### 块级作用域

ES6 之前只有

- 函数作用域
- 全局作用域

ES6 新增 let、const， 他们 定义的变量只作用于块级作用域

块级作用域产生

- { statement } 

此外需要注意 

- for 循环会产生两层嵌套作用域

  > ```javascript
      for(let i = 0; i < 4; i++){
        let i = 100;
        // 输出 100，在循环体作用域内部 i 重新声明了； 如果计数器的 i 和循环体的 i 在一个块级作用域下将会报错；
        console.log(i);
      }
    ```

- 在 let const 声明变量之前无法使用变量，不然会报错

### 解构

```javascript
/**
 *** 数组解构
 */
const arry = [1, 2, 3];

{
  const [a, b, c] = arry;
  console.log(a, b, c);
}
{
  // ...rest 只能出现在最后面
  const [a, ...rest] = arry;
  console.log(a, rest);
}

{
  // 简单应用
  let path = "path/router/name";
  let [, , name] = path.split("/");
  console.log(name);
}

/**
 *** 对象解构
 */
const obj = {
  a: 1,
  b: 2,
  c: 3,
  name: "",
};

{
  const { a, b, c } = obj;
  console.log(a, b, c);
}

{
  const name = "xiaodaidai";
  // 属性重命名
  const { name: objName } = obj;
  console.log(objName);
}

{
  // 属性重命名后赋默认值
  const { name: objName = "xiaodaidai" } = obj;
  console.log(objName);
}

{
  // 简单应用
  let { log, dir } = console;
  log("log");
  dir("dir");
}

```

### 模版字符串

- 可以插值、换行、支持表达式
- 带标签的模版字符串

```javascript
const name = 'xiaodaidai'
const msg = `i love you, ${name}`;

const address = 'jiangsu suzhou';

function tagFun(strings, name, addrss){
  // strings 是一个数组，这里就是 result 被 ${name}， ${address} 分割的字符数组
  // 答应结果是 [ 'hi, ', ', my address is ', '' ] 'xiaodaidai' 'jiangsu suzhou'
  console.log(strings, name, address)
  return strings[0] + name + strings[1] + address + strings[2];
}
const result = 	tagFun`hi, ${name}, my address is ${address}`;
console.log(result)
```



### 字符串、对象扩展方法

字符串

- includes
- startsWith
- endsWith

对象

- assign 返回值与 target 相等，可以实现对象浅拷贝 
- is 1. 解决数字正负 0 不等； 2. 解决 NaN === NaN false 问题；

```javascript
-0 === +0           // true
NaN === NaN         // false
Object.is(+0, -0);  // false
Object.is(NaN, NaN) // true
```



### 参数默认值与剩余参数

参数默认值

```javascript
function defaultParams(paramA, paramB = true) {} // 带我默认值的参数必须在最后面
```

剩余参数

```javascript
// ES5 
function funA() {
  // 通过 arguments 实现
  console.log(arguments[0]); // 伪数组
}

// ES6 通过 ... 操作符实现; 只能在参数最后一位且只能使用一次
function funB(...args){   
  console.log(args[0]);
}
```

### 对象字面量增强

```javascript

const a = 1;
const funA = () => { console.log('this is funA'); };
const obj = {
  a,                    // 属性名称简写
  funA,                 // 方法简写
  [Math.random()]: 111  // 计算属性名，属性名可以使用表达式
};
```

### Proxy Reflect

Proxy  对比 Object.defineProperty 优点

- 强大的监听能力
- 可以监视数组方法
- 对原始对象没有侵入

|       handler 方法       |                           触发方式                           |
| :----------------------: | :----------------------------------------------------------: |
|           get            |                         读取某个属性                         |
|           set            |                         写入某个属性                         |
|           has            |                          in 操作符                           |
|      deleteProperty      |                        delete 操作符                         |
|      getPrototypeOf      |                   Object.getPrototypeOf()                    |
|      setPrototypeOf      |                   Object.setPrototypeOf()                    |
|       isExtensible       |                    Object.isExtensible()                     |
|    preventExtensions     |                  Object.preventExtensions()                  |
| getOwnPropertyDescriptor |              Object.getOwnPropertyDescriptor()               |
|      defineProperty      |                   Object.defineProperty()                    |
|         ownKeys          | Object.getOwnPropertyNames()、Object.getOwnPropertySymbols() |
|          apply           |                         调用一个函数                         |
|        construct         |                     用 new 调用一个函数                      |



Reflect 对象统一了对象的操作方式

```javascript
// Reflect 对象统一了对象的操作方式
const objA = {
  name: 'xiaozuo',
  age: 18,
  sex: 0
};
console.log('name' in objA)  // true
console.log(delete objA['sex']);
console.log(objA.keys);

// 统一使用 Reflect 内置方法
console.log(Reflect.has(objA, 'name'))  // true
console.log(Reflect.deleteProperty(objA, 'age'));
console.log(Reflect.ownKeys(objA));
```



### class Symbol Promise

class 语法示例

```javascript
class Person {
  constructor(name) {
    this.name = name;
  },
  say() {
    console.log(`hi,my name is ${this.name}`)
  },
  // 添加静态方法， 注意 this 内部指向不再指向实例，而是 Person 类型本身
  static create(name) {
    return new Person(name);
  }
}

// new 创建实例
const personA = new Person('xiaozuo');

// 调用静态方法创建实例
const personB = Person.create('xiaodaidai');

/** 
 * 使用 extends 关键字实现继承
 */
class Student extends Person {
  constructor(name, number) {
    super(name);
    this.number = number
  },
  hello() {
    super().say();
    console.log(`my school number is ${this.number}`);
  }
}

```





